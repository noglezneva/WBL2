package main

import "fmt"

/*
	Паттерн "Команда" - поведенческий паттерн проектирования, который превращает запросы в объекты,
	позволяя передавать их как аргументы при вызове методов,
	ставить запросы в очередь, логировать их, а также поддерживать отмену операций.

	Применимость паттерна "Команда":
	Паттерн "Команда" полезен в ситуациях, когда требуется инкапсулировать
	запросы или операции в объекты. Он позволяет параметризовать клиента,
	создавая команды в виде отдельных объектов, которые могут быть
	переданы и использованы в различных ситуациях.
	Это особенно полезно в случаях, когда необходимо реализовать отмену,
	повтор и отложенное выполнение операций.

	Плюсы:
	* Убирает прямую зависимость между объектами, вызывающими операции, и объектами, которые их непосредственно выполняют.
	* Позволяет реализовать простую отмену и повтор операций.
	* Позволяет реализовать отложенный запуск операций.
	* Позволяет собирать сложные команды из простых.
	* Реализует принцип открытости/закрытости.

	Минусы
	* Усложняет код программы из-за введения множества дополнительных классов.
	* В некоторых случаях может приводить к нарушению инкапсуляции, когда команда имеет прямой доступ к приватным методам и свойствам получателя.

	Один из практических примеров использования паттерна "Команда" -
	это реализация системы управления очередью задач.
	Каждая задача может быть представлена в виде отдельной команды,
	реализующей интерфейс Command. Клиент может создавать команды и
	добавлять их в очередь. Затем, при необходимости, команды могут
	быть отменены, повторены или выполнены в отложенном режиме.
	Это позволяет гибко управлять выполнением задач и взаимодействовать
	с очередью задач.
*/
// Интерфейс команды
type Command interface {
	Execute()
}

// Конкретная команда
type ConcreteCommand struct {
	Receiver *Receiver
}

func (c *ConcreteCommand) Execute() {
	c.Receiver.Action()
}

// Получатель команды
type Receiver struct{}

func (r *Receiver) Action() {
	fmt.Println("Receiver: выполнение действия")
}

// Инвокер
type Invoker struct {
	command Command
}

func (i *Invoker) SetCommand(command Command) {
	i.command = command
}

func (i *Invoker) ExecuteCommand() {
	i.command.Execute()
}

func main() {
	// Создание получателя
	receiver := &Receiver{}

	// Создание команды и связывание с получателем
	command := &ConcreteCommand{
		Receiver: receiver,
	}

	// Создание и настройка инициатора
	invoker := &Invoker{}
	invoker.SetCommand(command)

	// Выполнение команды
	invoker.ExecuteCommand()
}

/*
В этом примере, интерфейс Command определяет метод Execute(),
а ConcreteCommand реализует этот метод, вызывая соответствующее
действие в объекте-получателе Receiver. Invoker использует команду,
которую ему задали, и выполняет её метод Execute().
*/
